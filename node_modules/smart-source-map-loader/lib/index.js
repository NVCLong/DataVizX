"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {};
exports.default = _default;
var _meta = require("./meta");
Object.keys(_meta).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _meta[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _meta[key];
    }
  });
});
var _path = require("path");
var _loaderUtils = _interopRequireDefault(require("loader-utils"));
var _util = require("./util");
var _uri = require("./uri");
var _exception = require("./exception");
var _comment = require("./comment");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
/**
 * Create resolver.
 *
 * @param {Function} resolve Resolve function.
 * @returns {Function} Resolve function.
 */
function createResolver(resolve) {
  const res = resolve;
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (context, request) {
      const r = yield new Promise((resolve, reject) => {
        res(context, request, (err, result) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(result);
        });
      });
      return r;
    });
    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
}

/**
 * Create resolver multiple from a resolver.
 *
 * @param {Function} resolver Resolve function.
 * @returns {Function} Resolve function.
 */
function createResolverMulti(resolver) {
  return /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (context, requests) {
      for (const request of requests) {
        try {
          // eslint-disable-next-line no-await-in-loop
          return yield resolver(context, request);
        } catch (err) {
          // Do nothing.
        }
      }
      return null;
    });
    return function (_x3, _x4) {
      return _ref2.apply(this, arguments);
    };
  }();
}

// eslint-disable-next-line import/no-default-export, jsdoc/require-jsdoc, no-unused-vars
function _default(_x5, _x6, _x7) {
  return _ref3.apply(this, arguments);
}
function _ref3() {
  _ref3 = _asyncToGenerator(function* (source, map, meta) {
    // eslint-disable-next-line no-invalid-this
    const self = this;
    const callback = self.async();
    const {
      resolve,
      addDependency,
      emitWarning,
      sourceMap,
      context,
      rootContext,
      resourcePath
    } = self;
    const resolver = createResolver(resolve);
    const resolverMulti = createResolverMulti(resolver);

    // If passed a buffer then convert to a string or emit warning and skip.
    let sourceString = null;
    try {
      sourceString = (0, _util.stringOrBufferCast)(source, 'utf8');
    } catch (err) {
      emitWarning(new _exception.Exception(`Failed to cast source to string: ${err}`));
      // eslint-disable-next-line prefer-rest-params
      callback(null, ...arguments);
      return;
    }

    // Parse source map comment or pass the arguments straight through.
    const parsed = (0, _comment.parse)(sourceString);
    if (!parsed) {
      // eslint-disable-next-line prefer-rest-params
      callback(null, ...arguments);
      return;
    }

    // If no source map requested, just output code without comment.
    if (!sourceMap) {
      callback(null, parsed.body);
      return;
    }
    let mapFile = null;
    let mapInfo = null;
    let mapCode = null;

    // Check if data URI.
    if ((0, _util.isDataURI)(parsed.url)) {
      mapInfo = (0, _util.stringAbbrev)(parsed.url, 64, '...');

      // Attempt to parse URL as a data URI.
      const dataURI = (0, _uri.data)(parsed.url);
      if (!dataURI) {
        emitWarning(new _exception.Exception(`Failed to parse data URI: ${mapInfo}`));
        callback(null, parsed.body);
        return;
      }

      // Attempt to decode source map content.
      try {
        mapCode = dataURI.body().toString(dataURI.charset);
      } catch (err) {
        emitWarning(new _exception.Exception(`Failed to decode data URI: ${mapInfo}: ${err}`));
        callback(null, parsed.body);
        return;
      }

      // Remember which file the source map came from.
      mapFile = resourcePath;
    } else {
      mapInfo = parsed.url;

      // Remove file protocol from the URL if present.
      const mapPath = parsed.url.replace(/^file:\/\//i, '');

      // Create list of possible file paths.
      // Compensates for comments that may not be encoded to spec.
      const mapPaths = (0, _comment.pathsFromURL)(mapPath);

      // Convert those paths to resolvable paths.
      const mapPathsRequest = mapPaths.map(p => _loaderUtils.default.urlToRequest(p));

      // Resolve the first one that exists or null.
      const resolved = yield resolverMulti(context, mapPathsRequest);

      // If file not resolved emit warning and skip.
      if (!resolved) {
        emitWarning(new _exception.Exception(`Failed to resolve source map: ${mapInfo}`));
        callback(null, parsed.body);
        return;
      }

      // Add the file as a dependency.
      addDependency(resolved);

      // Read the file or emit warning and skip.
      try {
        mapCode = yield (0, _util.readFileAsync)(resolved, 'utf-8');
      } catch (err) {
        emitWarning(new _exception.Exception(`Failed to read source map: ${mapInfo}: ${err}`));
        callback(null, parsed.body);
        return;
      }

      // Remember which file the source map came from.
      mapFile = resolved;
    }

    // Get context of the file that has the source map.
    const mapFileContext = (0, _path.dirname)(mapFile);

    // Try to parse the map data.
    let mapData = null;
    try {
      mapData = JSON.parse(mapCode);
    } catch (err) {
      emitWarning(new _exception.Exception(`Failed to parse source map: ${mapInfo}: ${err}`));
      callback(null, parsed.body);
      return;
    }

    // Loop over the sections to ensure source content.
    const mapMappings = (0, _util.sourceMapMappings)(mapData);
    for (const mapping of mapMappings) {
      const {
        sources
      } = mapping;
      if (!sources) {
        continue;
      }
      const sourceRoot = mapping.sourceRoot || '.';

      // Get list of sources or create empty list.
      const sourcesContent = mapping.sourcesContent = mapping.sourcesContent || [];

      // Loop over the sources looking for missing content.
      for (let i = 0; i < sources.length; i++) {
        const source = sources[i];
        const sourceContent = sourcesContent[i];

        // If has content or source is a data URI, nothing to read.
        if (
        // eslint-disable-next-line no-undefined
        sourceContent !== null && sourceContent !== undefined || (0, _util.isDataURI)(source)) {
          continue;
        }

        // Locate the source file.
        const sourcePath = `${sourceRoot}/${source}`;
        const sourceRequest = _loaderUtils.default.urlToRequest(sourcePath);

        // Resolve source file or emit warning and skip.
        let resolved = null;
        try {
          // eslint-disable-next-line no-await-in-loop
          resolved = yield resolver(mapFileContext, sourceRequest);
        } catch (err) {
          const info = `${mapInfo} -> ${sourceRequest}`;
          emitWarning(new _exception.Exception(`Failed to resolve source file: ${info}: ${err}`));
          callback(null, parsed.body);
          return;
        }

        // Add the file as a dependency.
        addDependency(resolved);

        // Read the file or emit warning and skip.
        let sourceCode = null;
        try {
          // eslint-disable-next-line no-await-in-loop
          sourceCode = yield (0, _util.readFileAsync)(resolved, 'utf-8');
        } catch (err) {
          const info = `${mapInfo} -> ${sourceRequest}`;
          emitWarning(new _exception.Exception(`Failed to read source file: ${info}: ${err}`));
          callback(null, parsed.body);
          return;
        }

        // Add source content to the list.
        sourcesContent[i] = sourceCode;
      }
    }

    // Get the path to the source map, relative if possible.
    const mapFilePath = (0, _util.pathRelativeIfSub)(rootContext, mapFile);

    // Rebase the source map base to the source map file.
    // This way webpack will have the real path to the source file.
    (0, _util.sourceMapRebase)(mapData, mapFilePath.replace(/\\/g, '/'));

    // All good, pass the body and parsed source map out.
    callback(null, parsed.body, mapData);
  });
  return _ref3.apply(this, arguments);
}
//# sourceMappingURL=index.js.map