{"version":3,"sources":["../src/createSpreadMapper.js"],"names":["createSpreadMapper","path","stats","result","attributeNames","optionsDefaults","opts","Object","assign","attributes","entries","filter","pair","attributeKeys","map","spreadAttributes","node","openingElement","attr","spread","attributeKey","destinationName","argument"],"mappings":";;;;;;;AAEA;;AAUA;;;;AAEA,MAAMA,kBAAkB,GAAG,CAACC,IAAD,EAAUC,KAAV,KAAkE;AAC3F,QAAMC,MAAM,GAAG,EAAf;AAEA,MAAI;AAACC,IAAAA;AAAD,MAAmBC,wBAAvB;;AAEA,MAAIH,KAAK,CAACI,IAAN,IAAcJ,KAAK,CAACI,IAAN,CAAWF,cAA7B,EAA6C;AAC3CA,IAAAA,cAAc,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,cAAlB,EAAkCF,KAAK,CAACI,IAAN,CAAWF,cAA7C,CAAjB;AACD;;AAED,QAAMK,UAAU,GAAGF,MAAM,CACtBG,OADgB,CACRN,cADQ,EAEhBO,MAFgB,CAERC,IAAD,IAAU;AAChB,WAAOA,IAAI,CAAC,CAAD,CAAX;AACD,GAJgB,CAAnB;AAMA,QAAMC,aAAa,GAAGJ,UAAU,CAACK,GAAX,CAAgBF,IAAD,IAAU;AAC7C,WAAOA,IAAI,CAAC,CAAD,CAAX;AACD,GAFqB,CAAtB;AAIA,QAAMG,gBAAgB,GAAGd,IAAI,CAACe,IAAL,CAAUC,cAAV,CAAyBR,UAAzB,CACtBE,MADsB,CACdO,IAAD,IAAU;AAChB,WAAO,iCAAqBA,IAArB,CAAP;AACD,GAHsB,CAAzB;;AAKA,OAAK,MAAMC,MAAX,IAAqBJ,gBAArB,EAAuC;AACrC,SAAK,MAAMK,YAAX,IAA2BP,aAA3B,EAA0C;AACxC,YAAMQ,eAAe,GAAGjB,cAAc,CAACgB,YAAD,CAAtC;;AAEA,UAAIjB,MAAM,CAACkB,eAAD,CAAV,EAA6B;AAC3BlB,QAAAA,MAAM,CAACkB,eAAD,CAAN,GAA0B,6BACxB,GADwB,EAExBlB,MAAM,CAACkB,eAAD,CAFkB,EAGxB,kCACEF,MAAM,CAACG,QADT,EAEE,6BACE,GADF,EAEE,0BAAc,GAAd,CAFF,EAGE,8BACE,IADF,EAEE,6BACEH,MAAM,CAACG,QADT,EAEE,uBAAWD,eAAX,CAFF,CAFF,EAME,0BAAc,EAAd,CANF,CAHF,CAFF,EAcE,0BAAc,EAAd,CAdF,CAHwB,CAA1B;AAoBD,OArBD,MAqBO;AACLlB,QAAAA,MAAM,CAACkB,eAAD,CAAN,GAA0B,kCACxBF,MAAM,CAACG,QADiB,EAExB,8BACE,IADF,EAEE,6BACEH,MAAM,CAACG,QADT,EAEE,uBAAWD,eAAX,CAFF,CAFF,EAME,0BAAc,EAAd,CANF,CAFwB,EAUxB,0BAAc,EAAd,CAVwB,CAA1B;AAYD;AACF;AACF;;AAED,SAAOlB,MAAP;AACD,CAnED;;eAqEeH,kB","sourcesContent":["// @flow\n\nimport {\n  Expression,\n  memberExpression,\n  binaryExpression,\n  conditionalExpression,\n  stringLiteral,\n  logicalExpression,\n  identifier,\n  isJSXSpreadAttribute\n} from '@babel/types';\nimport optionsDefaults from './schemas/optionsDefaults';\n\nconst createSpreadMapper = (path: *, stats: *): { [destinationName: string]: Expression } => {\n  const result = {};\n\n  let {attributeNames} = optionsDefaults;\n\n  if (stats.opts && stats.opts.attributeNames) {\n    attributeNames = Object.assign({}, attributeNames, stats.opts.attributeNames);\n  }\n\n  const attributes = Object\n    .entries(attributeNames)\n    .filter((pair) => {\n      return pair[1];\n    });\n\n  const attributeKeys = attributes.map((pair) => {\n    return pair[0];\n  });\n\n  const spreadAttributes = path.node.openingElement.attributes\n    .filter((attr) => {\n      return isJSXSpreadAttribute(attr);\n    });\n\n  for (const spread of spreadAttributes) {\n    for (const attributeKey of attributeKeys) {\n      const destinationName = attributeNames[attributeKey];\n\n      if (result[destinationName]) {\n        result[destinationName] = binaryExpression(\n          '+',\n          result[destinationName],\n          conditionalExpression(\n            spread.argument,\n            binaryExpression(\n              '+',\n              stringLiteral(' '),\n              logicalExpression(\n                '||',\n                memberExpression(\n                  spread.argument,\n                  identifier(destinationName),\n                ),\n                stringLiteral('')\n              )\n            ),\n            stringLiteral('')\n          )\n        );\n      } else {\n        result[destinationName] = conditionalExpression(\n          spread.argument,\n          logicalExpression(\n            '||',\n            memberExpression(\n              spread.argument,\n              identifier(destinationName),\n            ),\n            stringLiteral('')\n          ),\n          stringLiteral('')\n        );\n      }\n    }\n  }\n\n  return result;\n};\n\nexport default createSpreadMapper;\n"],"file":"createSpreadMapper.js"}